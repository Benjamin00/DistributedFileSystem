write operating concepts you have learned (describe) in the report
if you haven't done something, explain why

code: clean up if you can


Testing:
1. Start 3 data nodes on known parts, each as its own process
	- use StartDataNodes
	- in terminal, top will verify that there are three processes running
	- logging goes to DNode_<port>.log
2. Start NameNode
	- again, use top to verify a total of 4 java processes
	- logging goes to console
3. Start Client
	- enter commands like "append $FILE $CONTENT", "read $FILE"
	- append to a single file multiple times
	- read back the file, contents printed to console
	- verify that the correct contents returned
4. If needed, can inspect individual block files in Data_<port> directories

Data Node Design:
	- class data node has a queue of available blocks and a hashmap with "taken" block information
	- queue and hashmap have their own indvidual locks; locks are used whenever the structures are modified
	- each taken block has a file name, read lock, and write lock (using java's readWriteLock)
	- data node listens continuously on its port; it accepts a client connection from name node when a new message comes in; the message is handled in a new thread: data node handler
	- the reference to the data node is given as an argument to its thread; so data node methods can be called from the handler
	- locks were used for simplicity and with minimal scope to prevent deadlock or excessive blocking
	- with using locks, a data node has to manage its own resources; thus a handler has access to a single instance of a data node (representing a unqiue host); if data can be modified in one place it is simpler to ensure its safety
	- used java's readwritelock class to synchronize reads and writes; in order to allow a read on block x1 while writing to block x2, each block has its own read lock and its own write lock (we also get writer preference, and allowance of multiple readers for free with java's class).
	- once data node handler gets a message, it parses it, calls the appropriate method, formats a return message, and closes the thread (also cleans up client port and readers)
	- each instance of data node is run as an independent process; there is no shared memory or synchronization between data node processes; didn't want to share between processes because in a physical system, data nodes would likely be independent computers with no knowledge of any other nodes present
